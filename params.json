{"name":"Angular Waypoints","tagline":"An AngularJS module for working with jQuery Waypoints","body":"**Angular Waypoints** is an AngularJS module for working with [jQuery Waypoints](http://imakewebthings.com/jquery-waypoints/).\r\n\r\n## Dependencies\r\n* [AngularJS](https://angularjs.org/)\r\n* [jQuery](http://jquery.com/) &amp; [jQuery Waypoints](http://imakewebthings.com/jquery-waypoints/)\r\n* [lodash](http://lodash.com/)\r\n\r\n## Non-Angular Waypoints Example\r\n\r\n> Waypoints is a jQuery plugin that makes it easy to execute a function whenever you scroll to an element.\r\n\r\n```js\r\n// example from http://imakewebthings.com/jquery-waypoints/\r\n\r\n$('.thing').waypoint(function(direction) {\r\n  alert('Top of thing hit top of viewport.');\r\n});\r\n```\r\n\r\nThe above example from the jQuery waypoints homepage works well for most situations.  However, if you were to put the above code inside an AngularJS directive, you end up with a couple of drawbacks:\r\n\r\n* The waypoints implementation is hidden from the HTML.  All you know is that a directive is doing *something*, but you do not know the contents of the callback function.\r\n* If you modify a scope property in your callback, you'll need to manually call `$scope.$digest` to let angular process this new information.\r\n\r\n## Angular Waypoints Example\r\nWith Angular Waypoints, your template becomes declarative.  For example, you could toggle between two CSS classes (`sticky` and `notSticky`) by attatching a waypoint and using `ngClass` to listen to the waypoint flags:\r\n\r\n```html\r\n<div zum-waypoint=\"waypoints\"\r\n    down=\"flags.on\"\r\n    up=\"flags.off\"></div>\r\n<div ng-class=\"{\r\n    sticky : waypoints.flags.on,\r\n    notSticky : waypoints.flags.off\r\n}\"></div>\r\n```\r\n\r\nAngular Waypoints works by taking the control of the waypoints callback away from the developer.  When a waypoint is triggered by scrolling the page, the directive executes an internal callback that toggles a boolean flag based on the direction of the scroll.  These flags can be used by other directives (like `ngClass` or `ngIf`) to modify application state.\r\n\r\n## Installation\r\nInstall Angular Waypoints via [bower](http://bower.io/):\r\n\r\n```bash\r\n$ bower install angular-waypoints\r\n```\r\n\r\nAngular Waypoints comes with several packaged versions:\r\n\r\n* `dist/angular-waypoints.js` **Development** &mdash; AMD compatable, commented.\r\n* `dist/angular-waypoints.min.js` **Production** &mdash; Minified, stripped of comments.\r\n* `dist/angular-waypoints.all.js` **Standalone** &mdash; Same as the Development version, but includes unminified versions of lodash and jQuery Waypoints.\r\n* `dist/angular-waypoints.all.min.js` **Standalone Compressed** &mdash; Same as the Standalone version, but minified.\r\n* `dist/angular-waypoints.raw.js` **Raw** &mdash; This is a simple version that isn't very useful by itsself.  There is no `zumba.angular-waypoints` module.  The directive, controller, and service functions are all exposed to the global scope.  Use this if you want to package our code into another library, register individual components yourself, or do something custom.\r\n\r\n### Register the module as a dependency:\r\n\r\n```js\r\nangular.module('YourModule', ['zumba.angular-waypoints']);\r\n```\r\n\r\nAttach the `zum-waypoint` directive to each element for which you want to trigger a waypoint flag.  Each waypoint can be configured to use one flag for scrolling up, one flag for scrolling down, and an offset value if needed.  See the [jQuery Waypoints Documentation](http://imakewebthings.com/jquery-waypoints/#doc-options) for an explanation of offset.\r\n\r\n`up`, `down`, and `offset` are HTML attributes that are bound to the isolated scope of the directive.  Here is a full example of a template:\r\n\r\n```html\r\n<div zum-waypoint=\"waypoints\"\r\n    down=\"name.down\"\r\n    up=\"name.up\"\r\n    offset=\"20%\"></div>\r\n```\r\n#### Breakdown of the above example\r\n\r\n1. The `waypoints` property of the parent scope will be used to hold the flags triggered by the directive.  This is indicated by the expression passed to the bltWaypoint directive.  It should be a plain old javascript object `{}`.\r\n2. When the element is 20% away from the top of the viewport while scrolling down, `waypoints.name.down` will be set to `true`, and `waypoints.name.up` will be set to false.\r\n3. If the direction was scrolling up, `waypoints.name.down` will be set to `false`, and `waypoints.name.up` will be set to true.\r\n\r\n## Namespaced Flags\r\n\r\nNotice that the examples have included a \"namespace\" for the flags (in the first exmaple `flags.up` has the `flags` namespace).  This allows you to use several groups of waypoints on the same view. When toggling a waypoint flag to `true`, all other flags that share the same namespace will be toggled to `false`.  Flags that exist in another namespace are left unchanged.\r\n\r\nIf you do not use a namespace, the directive will store the flags inside a namespace called `globals`:\r\n\r\n```html\r\n<div zum-waypoint=\"waypoints\"\r\n    down=\"someFlag\"\r\n    up=\"anotherFlag\"></div>\r\n```\r\n\r\nThe above flags would be accessed via `waypoints.globals.someFlag` and `waypoints.globals.anotherFlag`\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}